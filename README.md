# ****ClasstingQuiz****

![image](https://user-images.githubusercontent.com/41819129/186859649-47bc4f23-0c32-4fdc-b699-049a4bb07b4f.png)

[ClasstingQuiz](https://classtingquiz.netlify.app/)

## 🙇‍♂️ **Introduction**

**ClasstingQuiz**는 간단한 '퀴즈'를 풀 수 있는 웹앱입니다. 사용자는 4개의 보기 중 문제에 답이라고 생각하는 답안을 선택하여 퀴즈를 진행합니다. 문제의 결과는 곧바로 나오며 5문제를 다 풀었을 때 틀린 문제를 오답 노트를 통해 복습할 수 있고, 해당 퀴즈를 다시 풀 수 있습니다.

## 🗓 Schedule

2022.08.19 ~ 2022.08.26 – 1 weeks

## 💿 Feature

- '퀴즈 풀기' 버튼을 클릭하여 퀴즈 풀기를 시작
  ![AnyConv com__퀴즈-기능1](https://user-images.githubusercontent.com/41819129/186862338-6bc70d65-7a11-456d-a5af-be54ecd33227.gif)
- 4개의 답안이 나오는 문제를 통해 퀴즈 진행
    - 선택한 답안이 맞았는지 틀렸는지 표시
    - 답안 선택 후 ‘다음 문항’ 버튼 활성화
    - ‘다음 문항' 버튼 클릭 시 다음 문항으로 이동
    - 퀴즈에서 문제를 맞히면 포인트를 획득
- 퀴즈 종료 후, 결과 정보 표시
    - 퀴즈를 종료할 때까지 소요된 시간
    - 정답, 오답 수
    - 정 오답에 대한 비율 파이차트
  ![AnyConv com__퀴즈-기능2](https://user-images.githubusercontent.com/41819129/186860552-ab768154-2321-4551-9262-0fcdafafb966.gif)

- 종료된 퀴즈에 대한 다시 풀기, 오답 노트 기능
    - 해당 퀴즈에서 틀린 문제에 대한 선택한 답안과 정답을 같이 표시하는 오답 노트 기능
    - 오답 노트로 학습 후 해당 퀴즈 다시 풀기 기능
  ![AnyConv com__퀴즈-기능3](https://user-images.githubusercontent.com/41819129/186862547-3580e58c-288b-4f79-aab1-bc09b48dc3d8.gif)  


## 📁 **Installation**

### Frontend

1. 프로젝트를 클론 후 루트 디렉토리 내부에서 다음 명령어 입력

```bash
yarn install or yarn
yarn start
```

### 서버 기본 주소

- Frontend (React): [http://localhost:3000](http://localhost:3030/)

## 🎖 Keyword

### Client State, Server State

리액트에서 상태는 변화되었을 때 리렌더링을 발생시키는 리액트의 핵심 개념이라고 생각합니다. 이런 상태를 효율적으로 관리하기 위해 Redux, Mobx 등 여러 가지 대안이 제시되었습니다. 그 중 이번 과제에서 Client State, Server State를 따로 관리하는 방식을 적용하였습니다. 서버에 저장되지 않고, 프론트 단에서 UI/UX와 관련된 상태들을 Client State로 생각하고, 기존의 로컬 상태 관리 훅 `useState` 과 비슷하게 전역으로 간편하게 상태를 관리할 수 있는 `Recoil`을 선택하였습니다. 서버에 관련된 State(문제 데이터)의 경우에는 따로 전역 상태를 관리하지 않고도 `useQuery` 훅을 이용하여 선언적으로 코드를 작성하고 데이터를 활용할 수 있는 `ReactQuery`를 사용하였습니다. 

두 개의 상태를 분리하여 사용함으로써, 관심사가 분리되어 코드를 작성할 때 서비스에 이슈가 있을 때 어떤 로직을 확인해야 할지 명확하게 보였습니다. 특히, 문제 데이터를 받아오는 로직을 커스텀 훅 (`useQuestionsQuery`)으로 모듈화하여 필요한 컴포넌트에서 적절하게 사용할 수 있었고, Jest로 테스트를할 때도 분리된 커스텀 훅을 통해 데이터를 적절하게 가지고 오는지 테스트 할 수 있었습니다.

또한, `ReactQuery` 의 쿼리키를 활용하여 서버에 계속 데이터를 요청하는 것이 아니라, 사용자가 ‘퀴즈 풀기’ 버튼을 클릭하였을 때만 새로운 데이터를 받아오고, 그 외에 경우에는 캐싱 된 데이터를 활용하였습니다.

더 나아가, 이 서비스의 확장을 생각하였을 때 사용자가 직접 퀴즈를 업로드하고, 문제를 수정할 수 있는 기능이 추가될 때  `ReactQuery`의 staleTime과 cacheTime을 적절하게 활용하여 서버의 자원과 동기화를 통해, 사용자에게 최신 정보를 제공해줄 수 있을 거로 생각합니다. 

하지만, 한계점 또는 단점이 존재하였습니다. 먼저, 두 개의 상태 관리 라이브러리를 올바르게 사용하기 위한 학습 시간이 하나의 라이브러리를 사용하였을 때 보다 많이 소요되었습니다. 또한, 초기 번들 사이즈가 하나를 사용하였을 때 더욱 커진다는 단점이 있다고 생각하였습니다.

마지막으로, 초반 프로젝트 설계 난이도가 높았습니다. 관심사를 분리하기 위해 모듈화를 진행하는 만큼 어떻게 두 개의 상태, 두 개의 라이브러리를 적절하게 사용할 수 있을까 고민하는데 초반에 시간을 많이 투자했던 거 같습니다. 고민의 결과로 앞서 말씀드렸던 커스텀 훅을 활용하여 올바르게 사용하고자 노력하였습니다.

상태 관리의 방식은 프론트엔드 개발자로서 제가 앞으로 계속 고민해야 하는 중요한 부분이라 생각합니다.

### Supense, ErrorBoundary

사용자에게 로딩, 에러가 발생했을 때 적절하게 화면에서 피드백을 주는 것이 사용자 경험을 높여줄 수 있다고 생각합니다. 그래서 이번 과제에서 `Supense`, `ErrorBoundary` 활용하였습니다.

기존에 비동기 데이터 패칭이 발생하였을 때 `isLoading`, `isError` 상태를 따로 컴포넌트 내부에 두어 로딩 또는 에러가 발생하였을 때 적절하게 사용자에게 화면을 보여줄 수 있었습니다.

하지만, 이러한 방식은 비동기 로직일 발생하는 각 컴포넌트 마다 상태를 따로 관리하고, 로딩 처리와 에러 처리가 혼합되어서 관리된다는 단점이 있다고 생각하였습니다. `Supense`, `ErrorBoundary` 컴포넌트를 마치 `Try Catch` 문으로 비동기 로직을 감싸는 것과 같이 컴퍼넌트 구조 최상위에 위치함으로써 로딩과 에러처리를 외부 상위 컴포넌트에 위임하고 각 상태에 따라 적절한 UI를 사용자에게 보여주었습니다. 이를 통해 코드를 간소화하고 직관적으로 코드를 작성하여 제가 생각했던 단점을 해결할 수 있었습니다.

### 컴포넌트 재사용성

퀴즈 페이지와 리뷰 페이지에 UI에 동일한 부분이 많았습니다. 문제의 정보를 보여주는 `QuestionWindow` 컴포넌트와 다음 문항으로 넘어갈 수 있는 `NextQuestionButton` 컴포넌트에 각 페이지별로 적절하게 상태와 버튼 클릭 이벤트 함수를 `Props`로 내려주어 따로 페이지별로 다른 컴포넌트를 사용하기보다는 기존의 컴포넌트를 재사용하였습니다. 이를 통해 제가 개발 중에 발생했던 이슈들에 대해 문제가 발생한 하나의 컴포넌트에만 관심을 쏟으면 되어 대응하기가 수월하다고 느꼈습니다.

## 🏔 Challenge

### API Response Encoding

과제 구현을 진행하면서, Open API에서 문제 정보를 받아왔을 때 문제, 답안 문자열에 `&quot`와 같은 HTML 이스케이프 문자가 포함된 것을 발견했습니다. 이 때문에 단순히 패칭한 데이터에 문자열을 그대로 사용하였을 때 이스케이프 문자가 포함되었습니다.

이를 해결하기 위해 `dangerouslySetInnerHTML` 속성을 사용하여 데이터를 `InnerHTML`로 활용하였습니다. 

### Protected Route

과제 요구사항 중 ‘사용자는 '퀴즈 풀기' 버튼을 클릭하여 퀴즈 풀기를 시작할 수 있다.’라는 부분이 존재했습니다.

사용자가 임의로 브라우저 입력창에 `/quiz`, `/result`, `/review` 라우터 경로로 접근하려고 할 때 아직 퀴즈를 시작하거나 풀지 않았기 때문에 화면에 보여주기 위한 데이터 또는 상태들이 존재하지 않습니다. 사용자가 퀴즈 풀기 버튼을 누르고, 퀴즈가 종료되었을 때 결과를 확인 후 오답 노트, 다시 풀기 과정을 진행할 수 있도록 해당 경로들에 대해 접근할 수 있는 조건을 확인하였습니다. 조건을 확인하는 로직을 한군데에서 관리하기 위해 `react-router-dom` 라이브러리의 중첩 라우터 방식을 활용했습니다. `ProtectedRoute` 함수형 컴포넌트를 만들어 `/quiz`, `/result`, `/review` 라우터 경로로 접근할 때 조건이 만족하지 않는다면 홈페이지로 리다이렉트, 만족한다면 `Outlet` 컴포넌트를 자식 컴포넌트를 성공적으로 렌더링할 수 있도록 해결하였습니다.

## 📚 Stack

### Frontend

- TypeScript
- ReactJS
- Recoil (Client state)
- React Query (Sever state)
- Jest
- Styled component

### Depoly

- Netlify

## 🚀 Outro

과제로 주신 퀴즈 웹앱 서비스는 언뜻 보면 구현하기 쉬워 보이지만 요구사항을 정확하게 확인하고, 디테일한 부분을 신경 쓴다면 고민해야 하는 부분이 많다고 느꼈습니다. 그리고 과제 문서에서 말씀해주신 대로, 실제로 회사에서 일한다는 마음가짐으로 과제의 완성도를 신경 쓰기 위해 노력하였습니다. 지금은 저 혼자 과제를 진행하였지만, 회사에서 이 프로젝트를 진행하였다면 협업을 원활하게 진행하기 위해 커밋 컨벤션에 신경을 썼습니다. 또한, 내가 작성한 코드를 다른 사람도 쉽게 이해하고 수정할 수 있도록 코드를 직관적이고 간결하게 작성할 수 있도록 노력하였습니다.

API가 준비되어 있고, 요구 사항이 명확한 좋은 과제를 통해 프론트엔드 개발자로서 고민하는 시간을 주신 것에 대해 감사합니다.
